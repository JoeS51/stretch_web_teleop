#!/usr/bin/env python3

import rospy
import tf2_ros
import actionlib
from geometry_msgs.msg import TransformStamped, Pose, Transform
from move_base_msgs.msg import MoveBaseAction, MoveBaseGoal
from stretch_teleop_interface.srv import NavigateToAruco
from tf.transformations import euler_from_quaternion, quaternion_from_euler
from math import sqrt, fabs, atan2
from control_msgs.msg import FollowJointTrajectoryGoal, FollowJointTrajectoryAction
from trajectory_msgs.msg import JointTrajectoryPoint

class ArucoNavigation:
    def __init__(self):
        # Service for enabling aruco navigation
        self.navigation_service = rospy.Service('navigate_to_aruco', NavigateToAruco, self.navigate_to_aruco_callback)
        self.aruco_name = ''
        self.tilt_range = [-1.0, 0.48]
        self.pan_range = [-4.07, 1.74]

        self.tf2_buffer = tf2_ros.Buffer()
        self.listener = tf2_ros.TransformListener(self.tf2_buffer)
        self.tf2_broadcaster = tf2_ros.TransformBroadcaster()

        self.action_client = actionlib.SimpleActionClient(
            "move_base",
            MoveBaseAction
        )

        self.trajectory_client = actionlib.SimpleActionClient(
            "stretch_controller/follow_joint_trajectory",
            FollowJointTrajectoryAction
        )

    def broadcast_tf(self, trans, name, ref):
        t = TransformStamped()
        t.header.stamp = rospy.Time.now()
        t.header.frame_id = ref
        t.child_frame_id = name
        t.transform = trans
        return t

    def calculate_diff(self, trans1, trans2):
        angle1 = euler_from_quaternion([trans1.transform.rotation.x,
                                        trans1.transform.rotation.y,
                                        trans1.transform.rotation.z,
                                        trans1.transform.rotation.w])
        angle2 = euler_from_quaternion([trans2.transform.rotation.x,
                                        trans2.transform.rotation.y,
                                        trans2.transform.rotation.z,
                                        trans2.transform.rotation.w])
        translation_diff = sqrt((trans1.transform.translation.x - trans2.transform.translation.x)**2 + \
                    (trans1.transform.translation.y - trans2.transform.translation.y)**2)
        angle_diff = fabs(angle1[2] - angle2[2])
        return translation_diff, angle_diff

    def snap_head_to_aruco(self, old_marker):
        try:                
            marker = self.tf2_buffer.lookup_transform('base_link', 'docking_station', rospy.Time())
        except (tf2_ros.LookupException, tf2_ros.ConnectivityException, tf2_ros.ExtrapolationException):
            marker = old_marker

        head = self.tf2_buffer.lookup_transform('base_link', 'link_head_tilt', rospy.Time())

        pose_diff_x = marker.transform.translation.x - head.transform.translation.x
        pose_diff_y = marker.transform.translation.y - head.transform.translation.y
        pose_diff_z = marker.transform.translation.z - head.transform.translation.z

        scalar = sqrt(pose_diff_x**2 + pose_diff_y**2 + pose_diff_z**2)
        pose_diff_x = pose_diff_x / scalar
        pose_diff_y = pose_diff_y / scalar
        pose_diff_z = pose_diff_z / scalar
        
        pan = atan2(pose_diff_y, pose_diff_x)
        tilt = atan2(pose_diff_z, -pose_diff_y)

        # if pan < self.pan_range[0]:
        #     pan = self.pan_range[0] - pan
        if pan > self.pan_range[1]:
            pan = -1*pan
            
        # if tilt < self.tilt_range[0]:
        #     tilt = self.tilt_range[0] - tilt
        # if tilt > self.tilt_range[1]:
        #     tilt = self.tilt_range[1] - tilt

        scan_point = JointTrajectoryPoint()
        scan_point.time_from_start = rospy.Duration(1.0)
        scan_point.positions = [tilt, pan]

        head_goal = FollowJointTrajectoryGoal()
        head_goal.trajectory.joint_names = ['joint_head_tilt', 'joint_head_pan']
        head_goal.trajectory.points = [scan_point]
        head_goal.trajectory.header.stamp = rospy.Time.now()
        head_goal.trajectory.header.frame_id = 'base_link'

        self.trajectory_client.cancel_all_goals()
        self.trajectory_client.send_goal(head_goal)
        self.trajectory_client.wait_for_result()
        

    def navigate_to_aruco_callback(self, req):
        self.aruco_name = req.name
        
        marker = self.tf2_buffer.lookup_transform('base_link', self.aruco_name, rospy.Time())
        trans = self.tf2_buffer.lookup_transform('map', self.aruco_name, rospy.Time())
        self.aruco_tf = self.broadcast_tf(trans.transform, self.aruco_name, 'map')
        rospy.loginfo("{} pose published to tf".format(self.aruco_name))

        # self.snap_head_to_aruco(marker)

        if self.aruco_name == 'docking_station':
            # Transform the docking station frame such that x-axis points out of the aruco plane and 0.5 m in the front of the dock
            # This facilitates passing the goal pose as this predock frame so that the robot can back up into the dock
            saved_pose = Transform()
            saved_pose.translation.x = 0.0
            saved_pose.translation.y = -1.0
            saved_pose.translation.z = 0.47
            saved_pose.rotation.x = -0.382
            saved_pose.rotation.y = -0.352
            saved_pose.rotation.z = -0.604
            saved_pose.rotation.w = 0.604
            tran = self.broadcast_tf(saved_pose, 'predock_pose', 'docking_station')
            self.tf2_broadcaster.sendTransform(tran)
            try:
                trans = self.tf2_buffer.lookup_transform('map', 'predock_pose', rospy.Time(), rospy.Duration(1.0))
                # Bring predock_frame at base_link level
                angles = euler_from_quaternion([trans.transform.rotation.x,
                                                trans.transform.rotation.y,
                                                trans.transform.rotation.z,
                                                trans.transform.rotation.w])
                q = quaternion_from_euler(0, 0, angles[2])
                trans.transform.translation.z = 0
                trans.transform.rotation.x = q[0]
                trans.transform.rotation.y = q[1]
                trans.transform.rotation.z = q[2]
                trans.transform.rotation.w = q[3]
                trans.header.stamp = rospy.Time.now()
                self.predock_tf = trans
                rospy.loginfo("Published predock pose")

                goal_pose = Pose()
                goal_pose.position.x = self.predock_tf.transform.translation.x
                goal_pose.position.y = self.predock_tf.transform.translation.y
                goal_pose.position.z = self.predock_tf.transform.translation.z
                goal_pose.orientation.x = self.predock_tf.transform.rotation.x
                goal_pose.orientation.y = self.predock_tf.transform.rotation.y
                goal_pose.orientation.z = self.predock_tf.transform.rotation.z
                goal_pose.orientation.w = self.predock_tf.transform.rotation.w

                action_goal = MoveBaseGoal()
                action_goal.target_pose.header.frame_id = "map"
                action_goal.target_pose.header.stamp = rospy.Time.now()
                action_goal.target_pose.pose = goal_pose

                self.action_client.send_goal(action_goal)
                self.action_client.wait_for_result()
                rospy.sleep(0.75)

                # self.snap_head_to_aruco(marker)

                new_trans = self.tf2_buffer.lookup_transform('map', self.aruco_name, rospy.Time())
                translation_diff, angle_diff = self.calculate_diff(trans, new_trans)
                if (translation_diff > 0.01 or angle_diff > 0.01):
                    self.action_client.cancel_all_goals()
                    self.navigate_to_aruco_callback(req)
            except (tf2_ros.LookupException, tf2_ros.ConnectivityException, tf2_ros.ExtrapolationException):
                rospy.loginfo("Could not publish pose to tf")
                pass

    def start(self):
        while not rospy.is_shutdown():
            # try:                
                # marker = self.tf2_buffer.lookup_transform('base_link', 'docking_station', rospy.Time())
                # head_tilt = self.tf2_buffer.lookup_transform('base_link', 'link_head_tilt', rospy.Time())                
                # pose_diff_x = marker.transform.translation.x - head_tilt.transform.translation.x
                # pose_diff_y = marker.transform.translation.y - head_tilt.transform.translation.y
                # pose_diff_z = marker.transform.translation.z - head_tilt.transform.translation.z

                # scalar = sqrt(pose_diff_x**2 + pose_diff_y**2 + pose_diff_z**2)
                # pose_diff_x = pose_diff_x / scalar
                # pose_diff_y = pose_diff_y / scalar
                # pose_diff_z = pose_diff_z / scalar

                # tilt = atan2(pose_diff_z, pose_diff_x)
                # if tilt < self.tilt_range[0]:
                #     tilt = self.tilt_range[0]
                
                # head_pan = self.tf2_buffer.lookup_transform('base_link', 'link_head_pan', rospy.Time())                
                # pose_diff_x = marker.transform.translation.x - head_pan.transform.translation.x
                # pose_diff_y = marker.transform.translation.y - head_pan.transform.translation.y
                # pose_diff_z = marker.transform.translation.z - head_pan.transform.translation.z

                # scalar = sqrt(pose_diff_x**2 + pose_diff_y**2 + pose_diff_z**2)
                # pose_diff_x = pose_diff_x / scalar
                # pose_diff_y = pose_diff_y / scalar
                # pose_diff_z = pose_diff_z / scalar
                
                # pan = atan2(pose_diff_y, pose_diff_x)
                # if pan > self.pan_range[1]:
                #     pan = self.pan_range[0]

                # scan_point = JointTrajectoryPoint()
                # scan_point.time_from_start = rospy.Duration(1.0)
                # scan_point.positions = [tilt, pan]

                # head_goal = FollowJointTrajectoryGoal()
                # head_goal.trajectory.joint_names = ['joint_head_tilt', 'joint_head_pan']
                # head_goal.trajectory.points = [scan_point]
                # head_goal.trajectory.header.stamp = rospy.Time.now()
                # head_goal.trajectory.header.frame_id = 'base_link'

                # self.trajectory_client.cancel_all_goals()
                # self.trajectory_client.send_goal(head_goal)
                
            # except (tf2_ros.LookupException, tf2_ros.ConnectivityException, tf2_ros.ExtrapolationException):
                # rospy.sleep(0.1)
                # continue

            rospy.sleep(0.1)

if __name__ == '__main__':
    rospy.init_node('aruco_navigation')
    node = ArucoNavigation()
    node.start()    